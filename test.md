# Тестове завдання — Інтернет-магазин

## 1) Контекст і мета

Спроєктувати базовий домен інтернет-магазину з фокусом на модель, яка **відповідає бізнес-правилам**. Завдання перевіряє здатність кандидата:

* моделювати сутності та визначати межі агрегатів;
* формулювати інваріанти й відобразити їх у поведінці об’єктів;
* продумувати транзакційні інваріанти та зміни станів без опори на інфраструктуру.

## 2) Технічні умови

* Мова: **PHP** (звісно, буде плюсом), будь-яка **інша**, або **псевдокод**.
* Архітектурний стиль: **тактичні патерни DDD, rich entities**.
  Орієнтири:

  * Тактичні патерни DDD — [https://socadk.github.io/design-practice-repository/activities/DPR-TacticDDD.html](https://socadk.github.io/design-practice-repository/activities/DPR-TacticDDD.html)
  * Rich entities — [https://medium.com/@inzuael/anemic-domain-model-vs-rich-domain-model-78752b46098f](https://medium.com/@inzuael/anemic-domain-model-vs-rich-domain-model-78752b46098f)
* Інфраструктура/фреймворк: **не обов’язково**. Буде плюсом використання **Doctrine ORM** (але не вимога).

## 3) Доменні сутності

### 3.1. Product (Товар)

* Кожен товар має **назву** та **вартість**.
* Товари поділені на дві групи: **поштучні** (банка консервів) і **вагові** (гречка розсипом). Поштучні можуть включатись в замовлення **тільки цілою кількістю**, вагові — **дробовими**.

**Бізнес-правила:**

* **Не може існувати більше одного товару з однаковою назвою.**

### 3.2. Order (Замовлення)

* У замовлення можна включити **один або декілька товарів**.
* Кожне замовлення має **статус**: `new`, `invoiced`, `paid`.

**Бізнес-правила:**

* **Вартість замовлення** = сума вартостей усіх включених позицій (ціна × кількість; кількість може бути дробовою для вагових товарів і цілою для поштучних.
* **Редагування замовлення** (для спрощення — лише **додавання** нових товарів) **дозволено тільки до створення першого рахунка**.
* Після створення будь-якого рахунка замовлення **редагувати неможливо**.
* **Статус замовлення** змінюється залежно від життєвого циклу рахунка:
  `new` — замовлення створене і не виставлявся рахунок; `invoiced` — є рахунок(и); `paid` — після оплати рахунка.
* **При виставленні нового рахунка** для замовлення **усі інші рахунки цього замовлення переходять у статус `cancelled`**.

### 3.3. Invoice (Рахунок)

* Рахунок є **документом на оплату** замовлення; може бути сплачений **різними платіжними методами** (реалізацію методів оплати робити **не потрібно**) - достатньо виділити відповідну абстракцію.

**Бізнес-правила:**

* Рахунок вважається **оплаченим**, тільки якщо **фактична сума оплати** збігається з **сумою рахунка**.
* Після оплати рахунка **замовлення переходить у статус `paid`**.
* **Неможливо двічі оплатити один і той самий рахунок.**
* Оплатити можливо **тільки рахунок зі статусом `new`**.
* **Статуси рахунка:** `new`, `cancelled`, `paid`.

## 4) Нефункціональні вимоги

* **Доменно-центрованість**: логіка правил має бути зосереджена в моделі а не в app-рівні.
* **Інваріанти**: неможливість дублю назви товару; заборона редагування замовлення після першого рахунка; оплата тільки `new`; неможливість повторної оплати - та інші
* **Транзакційні зміни станів** повинні бути продумані: кожна бізнес-операція - атомарна, транзакційна (не на рівні БД, а на рівні логіки)
* **Простота контрактів**: мінімум необхідних методів, що відповідають бізнес-операціям; уникати зайвих get/set без поведінки.

## 5) Функціональні вимоги

* **Товар**: має назву та вартість; належить до поштучних або вагових; назва у межах системи унікальна; кількість для вагових — дробова, для поштучних — ціла.
* **Замовлення**: об’єднує товари; обчислює загальну вартість як суму позицій; дозволяє додавати товари лише до моменту створення першого рахунка; після цього редагування неможливе; має життєвий цикл станів `new` → `invoiced` → `paid`; при створенні нового рахунка всі попередні рахунки по замовленню стають `cancelled`.
* **Рахунок**: фіксує суму до оплати; допускає різні способи оплати (без реалізації); може бути лише в станах `new`, `cancelled`, `paid`; сплачується тільки зі стану `new`; повторна оплата одного й того ж рахунка неможлива; оплата переводить відповідне замовлення у `paid`.

## 6) Очікуваний результат виконання

* **Створені PHP/інші/псевдокод класи** відповідно до цього завдання, з методами, які реалізують визначені бізнес-правила.
* **Діаграма класів** з їх полями і методами — *опційно*.
* **Юніт-тести** доменної логіки — *буде плюсом*.

## 7) Що НЕ потрібно включати

* Повністю реалізований проект з HTTP/CLI інтерфейсами.
* Реалізацію поза доменом: Application/Infrastructure layers.
* Діаграми таблиць (фокус на об’єктах, persistence — другорядне).
* Реальні інтеграції платіжних систем.
* Додаткові бізнес-вимоги, які не описані в завданні (податки/знижки/валюти тощо).

## 8) Критерії оцінювання

* **Моделювання домену — 20%**: коректні сутності, межі агрегатів.
* **Інваріанти та бізнес-правила — 40%**: реалізація описаних правил системи, неможливість обходу їх та порушення інваріантів.
* **Чистота контрактів — 20%**: мінімум необхідних методів Entity, які відповідають бізнес-операціям, відсутність зайвих getters/setters.
* **Якість реалізації — 20%**: зрозумілий код, коректні типи даних, додаткові пояснення в коментарях/README.

## 9) Підказки

* Почніть із **поділу відповідальностей** та **меж агрегатів**: де приймаються інваріанти, хто володіє станом і хто ініціює зміни.
* Для зміни станів використовуйте **методи, що відображають бізнес-події** (напр., «створити рахунок», «оплатити рахунок»), а не технічні set-и.
* **Транзакційність** мисліть як одну логічну операцію: «створити новий рахунок і зробити інші `cancelled`» має відбутися як єдиний атомарний крок у межах коректного агрегата/сервісу.
* Не думайте про **персистентність**: в реальній системі звісно цей додаток матиме якусь базу даних, але проєктуйте його так, ніби він весь **in-memory** 
* Якщо не впевнені, **опишіть словами** обрану стратегію (а не замовчуйте її): це краще, ніж сумнівна реалізація.

## 10) Формат виконання

* **GitHub-репозиторій** з кодом (якщо приватний — відкрити доступ для **@pavlokomarov**).

## 11) Коментар від СТО

> Я розумію, що виконання цього тестового може зайняти більше декількох годин, в той час як ми пропонуємо приділити йому не більше години. Це, зокрема, оцінка твого вміння балансувати між швидкістю та якістю — «зрізай кути», розставляй пріоритети, фокусуйся на головному. Ми не обмежуємо час на здачу тестового, тож я пропоную тобі ознайомитись із завданням, деякий час подумати над ним у фоні, ознайомитись із джерелами, якщо раніше в тебе був обмежений досвід із запропонованою архітектурою. І після того, як ти створиш драфт у своїй голові — перейти до його виконання.

Також у завданні наведено **приклад очікуваної реалізації однієї бізнес-вимоги**, щоб було зрозуміло формат вихідного результату.

Будь-які питання можна сміливо задавати протягом всього часу роботи над тестовим завданням.

## 12) Приклад очікуваної реалізації

> **Вимога:** «При виставленні нового рахунка для замовлення всі інші рахунки цього замовлення переходять у `cancelled`; оплатити можна лише `new`; повторна оплата неможлива».

```php
final class Order
{
    /** ... інші властивості ... */

    /**
     * Створює новий рахунок для поточного замовлення і переводить усі попередні рахунки у cancelled.
     */
    public function issueInvoice(): Invoice
    {
        // 1) Скасувати всі попередні рахунки цього замовлення
        foreach ($this->invoices as $invoice) {
            if ($invoice->isNew()) {
                $invoice->cancel();
            }
        }

        // 2) Створити новий рахунок із поточною сумою замовлення
        $invoice = new Invoice($this);
        $this->invoices[] = $invoice;

        // 3) Оновити статус замовлення (має принаймні один рахунок)
        $this->status = OrderStatus::INVOICED;
        return $invoice;
    }
}
```
